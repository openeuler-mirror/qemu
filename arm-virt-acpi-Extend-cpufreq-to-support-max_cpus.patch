From 91fed8840b004ec7bc91969afa10f03e13f311c4 Mon Sep 17 00:00:00 2001
From: Keqian Zhu <zhukeqian1@huawei.com>
Date: Wed, 22 Apr 2020 19:52:58 +0800
Subject: [PATCH] arm/virt/acpi: Extend cpufreq to support max_cpus

We will support CPU hotplug soon, so extend memory region size to
allow hotplugged CPU access cpufreq space.

Signed-off-by: Keqian Zhu <zhukeqian1@huawei.com>
---
 hw/acpi/cpufreq.c | 15 ++++++---------
 1 file changed, 6 insertions(+), 9 deletions(-)

diff --git a/hw/acpi/cpufreq.c b/hw/acpi/cpufreq.c
index d02a25a6de..38dcab5683 100644
--- a/hw/acpi/cpufreq.c
+++ b/hw/acpi/cpufreq.c
@@ -84,6 +84,7 @@ typedef struct CpuhzState {
     uint32_t PerformanceLimited;
     uint32_t LowestFreq;
     uint32_t NominalFreq;
+    uint32_t num_cpu;
     uint32_t reg_size;
 } CpuhzState;

@@ -95,10 +96,7 @@ static uint64_t cpufreq_read(void *opaque, hwaddr offset,
     uint64_t r;
     uint64_t n;

-    MachineState *ms = MACHINE(qdev_get_machine());
-    unsigned int smp_cpus = ms->smp.cpus;
-
-    if (offset >= smp_cpus * CPPC_REG_PER_CPU_STRIDE) {
+    if (offset >= s->num_cpu * CPPC_REG_PER_CPU_STRIDE) {
         warn_report("cpufreq_read: offset 0x%lx out of range", offset);
         return 0;
     }
@@ -166,11 +164,10 @@ static uint64_t cpufreq_read(void *opaque, hwaddr offset,
 static void cpufreq_write(void *opaque, hwaddr offset,
                            uint64_t value, unsigned size)
 {
+    CpuhzState *s = CPUFREQ(opaque);
     uint64_t n;
-    MachineState *ms = MACHINE(qdev_get_machine());
-    unsigned int smp_cpus = ms->smp.cpus;

-    if (offset >= smp_cpus * CPPC_REG_PER_CPU_STRIDE) {
+    if (offset >= s->num_cpu * CPPC_REG_PER_CPU_STRIDE) {
         error_printf("cpufreq_write: offset 0x%lx out of range", offset);
         return;
     }
@@ -251,9 +248,9 @@ static void cpufreq_init(Object *obj)
     CpuhzState *s = CPUFREQ(obj);

     MachineState *ms = MACHINE(qdev_get_machine());
-    unsigned int smp_cpus = ms->smp.cpus;
+    s->num_cpu = ms->smp.max_cpus;

-    s->reg_size = smp_cpus * CPPC_REG_PER_CPU_STRIDE;
+    s->reg_size = s->num_cpu * CPPC_REG_PER_CPU_STRIDE;
     if (s->reg_size > MAX_SUPPORT_SPACE) {
         error_report("Required space 0x%x excesses the max support 0x%x",
                  s->reg_size, MAX_SUPPORT_SPACE);
--
2.19.1
